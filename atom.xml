<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://norwayrainz.github.io</id>
    <title>Jamie的奥兹海默症预防针</title>
    <updated>2021-11-01T14:45:00.256Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://norwayrainz.github.io"/>
    <link rel="self" href="https://norwayrainz.github.io/atom.xml"/>
    <subtitle>想在海里跑</subtitle>
    <logo>https://norwayrainz.github.io/images/avatar.png</logo>
    <icon>https://norwayrainz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Jamie的奥兹海默症预防针</rights>
    <entry>
        <title type="html"><![CDATA[#踩坑日记# 记一次git 绕过不明bug]]></title>
        <id>https://norwayrainz.github.io/post/caikengdiary1/</id>
        <link href="https://norwayrainz.github.io/post/caikengdiary1/">
        </link>
        <updated>2021-11-01T13:42:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="gitlab就不能clone-密码我也输了啊-整个大无语">🙅Gitlab就不能clone 密码我也输了啊 整个大无语</h1>
<h2 id="事情是这样的">事情是这样的</h2>
<p>师父给我小任务改代码，结果发现不能clone项目，一开始还以为是权限的问题，结果找了后台管理员发现我账号没问题但就是说我输密码不对，但是网页是正常登录的，最后是在师父电脑上登了我的账号之后我再clone就正常了，离谱吧。<br>
就这么迷迷糊糊的过了周末，今天上班clone新代码的时候又来，clone输入密码后失败。好家伙，我这次退了重新登录，网页版依然没问题，我就纳闷儿了。搜了一波报错的解决方案，说是sshkey的问题，折腾了半天，发现有一个3年钱的sshkey，好家伙，会不会就是因为这个key的密码和我mac账户的密码不一样，<br>
所以失败啊🙄。<br>
就参考了大佬们和gitlab官方的方法生成新的sshkey。</p>
<ol>
<li>就不检查已存在的sshkey了 就是因为这个key有问题才踩坑的（吧？）</li>
<li>生成新的sshkey<pre><code class="language-shell">% ssh-keygen -t ed25519 -C &quot;&lt;comment&gt;&quot; 
#ed25519 是一种加密算法 可以选择RSA等 comment 内容会出现在.pub（公钥）文件中
</code></pre>
</li>
<li>然后连按3次回车 存在默认路径就好</li>
<li>输入<pre><code class="language-shell">cat ~/.ssh/id_ed25519.pub
# ssh-ed25519 AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc...
</code></pre>
</li>
<li>ssh开头的内容到邮箱结束都是公钥的内容全都复制下来</li>
<li>到gitlab的页面粘贴 再给这个sshkey一个名字就好。</li>
<li>私钥再没有pub后缀的同名文件里，要保护好。</li>
<li>最后<pre><code class="language-shell">ssh -T git@xxx.com
# 如果看到successfully 那恭喜你嘿嘿！
</code></pre>
</li>
</ol>
<h2 id="这样就可以正常clone啊什么的了">👍这样就可以正常clone啊什么的了</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSO单点登录]]></title>
        <id>https://norwayrainz.github.io/post/sso/</id>
        <link href="https://norwayrainz.github.io/post/sso/">
        </link>
        <updated>2021-09-16T01:49:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要有ssosingle-signon">🤔为什么要有sso（single signon）</h1>
<p>sso单点登录保证了一个账户在多个系统上实现单一用户的登录，<br>
由于现在网站系统越来越复杂，内容、服务都越来越多，不同的服务之间的通信，<br>
如何让用户不用重复登录就可以访问用以顶域下的所有服务呢，现在比较流行的方案就是sso。</p>
<h1 id="实现sso">🔑实现sso</h1>
<p>在server端是根据sessionId来判断用户，client端携带cookie告知服务端身份,<br>
用户注册登录知乎把用户相关信息存入redis，设置过期时间，key为一个token，使用uuid，uuid生成后<br>
存入cookie中，登录后需要重置redis和cookie的失效时间。</p>
<h1 id="sso原理">📔sso原理</h1>
<p>CAS标准流程<br>
<img src="https://norwayrainz.github.io/post-images/1631758462027.png" alt="" loading="lazy"></p>
<ol>
<li>用户访问某需要登录验证的App系统</li>
<li>被验证失败 则302重定向到CAS系统（sso系统），并将参数encode到URL中，sso系统发现未用户无登录session，跳转到sso验证</li>
<li>用户填写登录sso，登陆信息及login ticket，post到body中，验证成功后生成sso session，CASTGC（ticket granting cookie)含有Ticket Granting Ticket（TGT）,TGE作为sso session的session key，service ticket传给用户</li>
<li>持有ST跳转到要访问的App系统，App系统请求CAS server验证ST有效性</li>
<li>CAS验证通过返回 200 + 包含成功信息和已验证的主和任意参数的XML文档给App系统</li>
<li>App系统写入session 状态设置域下cookie, 并除去ST信息 防止地址栏泄露</li>
<li>再次访问时携带cookie即登录状态</li>
<li>访问App2时，跳转到CAS server验证cookie中的TGT 成功则携带ST返回</li>
<li>携带ST访问App2，aap2 请求CAS server验证ST</li>
<li>返回200 + XML文档</li>
<li>App2 建立session，生成域内cookie 返回</li>
<li>用户携带cookie访问 成功</li>
</ol>
<h1 id="总结">📝总结</h1>
<ol>
<li>sso保障各业务用户资源安全</li>
<li>避免用户重复登录</li>
<li>ST需要CAS server验证有效性 防止用户伪造</li>
<li>TGT在访问不同App的时候带上可以交给sso验证是否为同一个用户</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言排序——快速排序]]></title>
        <id>https://norwayrainz.github.io/post/GoQuickSort/</id>
        <link href="https://norwayrainz.github.io/post/GoQuickSort/">
        </link>
        <updated>2021-08-20T13:42:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="算法讲解">💡算法讲解</h1>
<p>快速排序是Charles Antony Richard Hoare，(东尼·霍尔) 在 1962 年提出，来改进冒泡排序的算法。<br>
是分治和递归思想在排序算法中的应用</p>
<p>1 在待排序的数列中，选择一个元素作为pivot将数列分成两个区域<br>
2 默认将pivot左边的区域放入比pivot小的数，右边则放入比pivot大的数，相同的数可以任意放在一边，操作完后，pivot将会在排序完成后的最终位置上，这个称作为partition（分区）操作。<br>
3 每个区域内各自递归</p>
<h2 id="特点">特点</h2>
<p>一般情况下排序n个元素需要O(nlogn)次,最坏的情况下每次都取到最大或最小值需要O(n^2)次</p>
<h1 id="代码实现">代码实现</h1>
<pre><code class="language-go">func quickSort(nums []int, left, right int) {
    if left &lt; right {
        pivot := partition(nums, left, right)
        //左半区
        quickSort(nums, left, pivot - 1)
        //右半区
        quickSort(nums, pivot+1, right)
    }
}
func partition(nums []int, left, right int) int {
    pivot := nums[left]//默认以第一个数为基准
    for left &lt; right {
        //右指针值&gt;pivot时左移
        for left &lt; right &amp;&amp; pivot &lt;= nums[right]{
            right--
        }
        //右指针值&lt;pivot时与nums[left]交换
        nums[left] = nums [right]
        //左指针值&lt;pivot时右移
        for left &lt; right &amp;&amp; pivot &gt;= nums[left]{
            left++
        }
        //左指针值&gt;pivot时与nums[right]交换
        nums[right] = nums[left]
    }
    //返回基准值的索引,为最终顺序
    nums[left] = pivot
    return left
}
//测试
func TestQuickSort(t *testing.T) {
    nums := []int {2,44,4,8,33,1,22,-11,6,34,55,54,9}
    quickSort(nums,0, len(nums) - 1)
    t.Log(nums)
}
</code></pre>
<h2 id="细节">🔸细节</h2>
<p>以左侧第一个数为基准时，必须先从右侧开始扫描，最后和基准互换位置时才不会出现左侧有数比基准大的情况，例如：<br>
<font color = "green" size = "5"> i                 j</font><br>
<font color = "green" size = "8">6,1,2,7,9</font></p>
<p>如上所示<br>
当<code>for left &lt; right &amp;&amp; pivot &lt;= nums[right]</code>时<br>
j在扫描到7之后会往左走一个，即2，<br>
当i到1时符合循环，往右走一个即2，此时不再满足i &lt; j 则停止。<br>
此时i所在的元素是比最左元素小的 交换后正确。<br>
若从左边先扫描 i 在扫描到2时满足循环，继续向右走一个，即7，<br>
此时j也会停在7的位置，若7与最左元素6交换显然不符合左侧都小于基准元素的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言排序——总结]]></title>
        <id>https://norwayrainz.github.io/post/go-yu-yan-pai-xu-zong-jie-nei-bu-pai-xu-1/</id>
        <link href="https://norwayrainz.github.io/post/go-yu-yan-pai-xu-zong-jie-nei-bu-pai-xu-1/">
        </link>
        <updated>2021-07-19T08:57:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="关于为什么学go">🤔关于为什么学Go</h1>
<p>自从面字节被虐了之后得知后台都用的Go就打算转Go了。其实也是Java卷不动了，早转晚转都得转，不如现在转！<br>
然后在默默学习Go的过程中感觉到Go还是有很多优势的比如说语法简单什么的，然后也尝试用Go去刷</p>
<p><strong>LeetCode</strong> 。刷到以前写过的题就会用Go去重写一遍，慢慢就爱上了这个语言，那就用他来巩固知识吧</p>
<h2 id="排序">👇排序</h2>
<p>排序故名思意就是一种目的是将乱序的元素排列成有序的状态，八大排序算法都属于内部排序，即数据全部记录在内存中无需访问外存。</p>
<h3 id="稳定排序">稳定排序</h3>
<p>稳定的排序算法会让键值相等的记录维持相同的次序，排序前后相对位置不变，以下列举了要细说的排序算法</p>
<ul>
<li>冒泡排序(Bubble sort)</li>
<li>插入排序(Insertion sort)</li>
<li>归并排序(Merge sort)</li>
<li>基数排序(Radix sort)</li>
<li>桶排序(Bucket sort)</li>
</ul>
<h3 id="非稳定排序">非稳定排序</h3>
<ul>
<li>选择排序(Select sort)</li>
<li>希尔排序(Shell sort)</li>
<li>堆排序(Heap sort)</li>
<li>快速排序(Quick sort)</li>
</ul>
<!-- 中间应该会贴上写好的文章的链接在这里 -->
<h2 id="️总结">✍️总结</h2>
<table>
<thead>
<tr>
<th style="text-align:center">Algorithm</th>
<th style="text-align:center">Best</th>
<th style="text-align:center">Average</th>
<th style="text-align:center">Worst</th>
<th style="text-align:center">Stability</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Quick sort</td>
<td style="text-align:center">O(n log(n))</td>
<td style="text-align:center">O(n log(n))</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">❌</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
</feed>