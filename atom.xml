<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://norwayrainz.github.io</id>
    <title>Jamie的奥兹海默症预防针</title>
    <updated>2021-08-20T14:40:21.229Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://norwayrainz.github.io"/>
    <link rel="self" href="https://norwayrainz.github.io/atom.xml"/>
    <subtitle>想在海里跑</subtitle>
    <logo>https://norwayrainz.github.io/images/avatar.png</logo>
    <icon>https://norwayrainz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Jamie的奥兹海默症预防针</rights>
    <entry>
        <title type="html"><![CDATA[Go语言排序——快速排序]]></title>
        <id>https://norwayrainz.github.io/post/GoQuickSort/</id>
        <link href="https://norwayrainz.github.io/post/GoQuickSort/">
        </link>
        <updated>2021-08-20T13:42:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="算法讲解">💡算法讲解</h1>
<p>快速排序是Charles Antony Richard Hoare，(东尼·霍尔) 在 1962 年提出，来改进冒泡排序的算法。<br>
是分治和递归思想在排序算法中的应用</p>
<p>1 在待排序的数列中，选择一个元素作为pivot将数列分成两个区域<br>
2 默认将pivot左边的区域放入比pivot小的数，右边则放入比pivot大的数，相同的数可以任意放在一边，操作完后，pivot将会在排序完成后的最终位置上，这个称作为partition（分区）操作。<br>
3 每个区域内各自递归</p>
<h2 id="特点">特点</h2>
<p>一般情况下排序n个元素需要O(nlogn)次,最坏的情况下每次都取到最大或最小值需要O(n^2)次</p>
<h1 id="代码实现">代码实现</h1>
<pre><code class="language-go">func quickSort(nums []int, left, right int) {
    if left &lt; right {
        pivot := partition(nums, left, right)
        //左半区
        quickSort(nums, left, pivot - 1)
        //右半区
        quickSort(nums, pivot+1, right)
    }
}
func partition(nums []int, left, right int) int {
    pivot := nums[left]//默认以第一个数为基准
    for left &lt; right {
        //右指针值&gt;pivot时左移
        for pivot &lt;= nums[right]{
            right--
        }
        //右指针值&lt;pivot时与nums[left]交换
        nums[left] = nums [right]
        //左指针值&lt;pivot时右移
        for pivot &gt;= nums[left]{
            left++
        }
        //左指针值&gt;pivot时与nums[right]交换
        nums[right] = nums[left]
    }
    //返回基准值的索引,为最终顺序
    nums[left] = pivot
    return left
}
//测试
func TestQuickSort(t *testing.T) {
    nums := []int {2,44,4,8,33,1,22,-11,6,34,55,54,9}
    quickSort(nums,0, len(nums) - 1)
    t.Log(nums)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言排序——总结]]></title>
        <id>https://norwayrainz.github.io/post/go-yu-yan-pai-xu-zong-jie-nei-bu-pai-xu-1/</id>
        <link href="https://norwayrainz.github.io/post/go-yu-yan-pai-xu-zong-jie-nei-bu-pai-xu-1/">
        </link>
        <updated>2021-07-19T08:57:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="关于为什么学go">🤔关于为什么学Go</h1>
<p>自从面字节被虐了之后得知后台都用的Go就打算转Go了。其实也是Java卷不动了，早转晚转都得转，不如现在转！<br>
然后在默默学习Go的过程中感觉到Go还是有很多优势的比如说语法简单什么的，然后也尝试用Go去刷</p>
<p><strong>LeetCode</strong> 。刷到以前写过的题就会用Go去重写一遍，慢慢就爱上了这个语言，那就用他来巩固知识吧</p>
<h2 id="排序">👇排序</h2>
<p>排序故名思意就是一种目的是将乱序的元素排列成有序的状态，八大排序算法都属于内部排序，即数据全部记录在内存中无需访问外存。</p>
<h3 id="稳定排序">稳定排序</h3>
<p>稳定的排序算法会让键值相等的记录维持相同的次序，排序前后相对位置不变，以下列举了要细说的排序算法</p>
<ul>
<li>冒泡排序(Bubble sort)</li>
<li>插入排序(Insertion sort)</li>
<li>归并排序(Merge sort)</li>
<li>基数排序(Radix sort)</li>
<li>桶排序(Bucket sort)</li>
</ul>
<h3 id="非稳定排序">非稳定排序</h3>
<ul>
<li>选择排序(Select sort)</li>
<li>希尔排序(Shell sort)</li>
<li>堆排序(Heap sort)</li>
<li>快速排序(Quick sort)</li>
</ul>
<!-- 中间应该会贴上写好的文章的链接在这里 -->
<h2 id="️总结">✍️总结</h2>
<table>
<thead>
<tr>
<th style="text-align:center">Algorithm</th>
<th style="text-align:center">Best</th>
<th style="text-align:center">Average</th>
<th style="text-align:center">Worst</th>
<th style="text-align:center">Stability</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Quick sort</td>
<td style="text-align:center">O(n log(n))</td>
<td style="text-align:center">O(n log(n))</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">❌</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
</feed>